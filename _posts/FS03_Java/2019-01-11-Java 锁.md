---
layout: post
category: java
---

## Monitor机制

每一个对象都有一个monitor，即监视器。
Monitor的机制如下图：

![Java Monitor机制][Java Monitor机制]

- The Owner：同一时刻，只能有一个线程持有monitor。
- Entry Set：当一个线程要获取monitor时，会首先进入entry-set排队，如果monitor没有被其它线程持有，这个线程会和wait-set中被唤醒的其它线程竞争monitor。
- Wait Set：当一个线程持有monitor时，该monitor关联的对象调用了wait()方法，那么这个线程会释放monitor，并且进入wait-set中等待。然后，当该monitor关联的对象调用了notify()或notifyAll()方法后，wait-set中的线程被唤醒，被唤醒的线程将与entry-set中的线程竞争monitor。（**notify()方法会随机唤醒一个线程。**）

## 死锁的4个条件

- **互斥条件**：该资源任意一个时刻只由一个线程占用。
- **请求与保持条件**：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
- **不剥夺条件**：线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
- **循环等待条件**：若干进程之间形成一种头尾相接的循环等待资源关系。

## 锁的分类

### 线程是否锁住同步资源？

- 锁住

**悲观锁**

认为自己在使用数据的时候一定有别的线程来修改数据。
synchronized关键字和Lock的实现类都是悲观锁。

- 不锁住

**乐观锁**

认为自己在使用数据时不会有别的线程修改数据。
无锁编程，CAS算法，Java原子类。

### 锁住同步资源失败，线程是否阻塞？

- 阻塞
- 不阻塞

**自旋锁**

避免线程切换的开销。
要占用处理器的时间。

**适应性自旋锁**

自动调节自旋等待时间。
CAS算法，Java原子类。

### 多个线程竞争同步资源的流程细节区别？

- 不锁住资源，多个线程中只有一个能修改资源成功，其它线程会重试。

**无锁**

- 同一个线程执行同步资源时自动获取资源。

**偏向锁**

- 多个线程竞争同步资源时，没有获取资源的线程自旋等待锁释放。

**轻量级锁**

- 多个线程竞争同步资源时，没有获取资源的线程阻塞等待唤醒。

**重量级锁**

### 多个线程竞争锁时要不要排队？

- 排队

**公平锁**

- 先插队，插队失败再排队

**非公平锁**

### 一个线程中的多个流程能不能获取同一把锁？

- 能

**可重入锁**

- 不能

**非可重入锁**

### 多个线程能不能共享一把锁？

- 能

**共享锁**

- 不能

**排他锁**


[Java Monitor机制]:{{ site.url }}/assets/pics/java_monitor.jpg