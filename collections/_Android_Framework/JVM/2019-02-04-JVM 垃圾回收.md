---
layout: post
category: JVM
---

## 垃圾回收策略
年青代和年老代采用不同的垃圾回收策略，年青代使用Copy算法，年老代使用Mark算法。
### 引用计数（Reference Counting）
每有一个引用则增加一个计数，只收集计数为0的对象。​缺点是无法处理循环引用的问题。
### 标记-清除（Mark-Sweep）
此算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除（清除后产生了内存碎片）。缺点是​此算法需要暂停整个应用，同时，会产生内存碎片。
### 复制（Copying）
此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。缺点是需要两倍内存空间。
### 标记-整理（Mark-Compat）
此算法结合了“标记-清除”和“复制”两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，把清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。​此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。
## 年青代
- Eden区
- 两个Survivor
    - From
    - To
    
## 年老代
## 持久代